# Отчет по лабораторной работе №8

## Данные студента
- **ФИО:** Мазепа Илья Алексеевич
- **Группа:** М8О-209Б-23
- **Вариант:** 11
- **GitHub репозиторий:** [Ссылка на репозиторий](https://github.com/Tyhyqo/mai_oc)

## Цель работы
Приобретение практических навыков диагностики работы программного обеспечения.

## Задание
При выполнении лабораторных работ по курсу ОС необходимо продемонстрировать ключевые системные вызовы, которые в них используются и то, что их использование соответствует варианту ЛР. 

По итогам выполнения всех лабораторных работ отчет по данной ЛР должен содержать краткую сводку по исследованию написанных программ.

## Средства диагностики
**OC Unix:** `strace`

## Лабораторная работа №1

### Описание программы
Программа состоит из трех частей: `parent`, `child_1` и `child_2`. Родительский процесс создает два дочерних процесса и взаимодействует с ними через каналы (`pipe`).

### Команда для выполнения `strace`:
```sh
strace -o strace_lab_1.txt ./parent
```

### Анализ `strace`
1. **execve(...)** — запуск файла `parent`.
2. **openat(...)** / **mmap(...)** — загрузка и отображение `libc.so.6`.
3. **pipe2(...)** — создание нескольких каналов для обмена данными.
4. **clone(...)** — запуск двух дочерних процессов.
5. **close(...)** — закрытие неиспользуемых дескрипторов.
6. **read(...)** / **write(...)** — чтение строк из stdin и передача в каналы.
7. **getrandom(...)** — получение случайных данных (идентификаторы).
8. **wait4(...)** — ожидание завершения дочерних процессов, освобождение ресурсов.
9. **exit_group(0)** — завершение программы.

## Лабораторная работа №2

### Описание программы
Программа для лабораторной работы №2 состоит из одного файла `main.c` и создает несколько потоков с помощью `pthread_create`. Каждый поток обрабатывает данные, используя общую память и системные вызовы для управления сигналами. Передача данных и синхронизация осуществляются с помощью `pthread_barrier_t`.

### Команда для выполнения `strace`:

```sh
strace -o strace_lab_2.txt ./main 8
```

### Анализ `strace`
1. **newfstatat(…)**:
   - Получает информацию о файле или о связанном объекте по файловому дескриптору (здесь `fd=0` или `fd=3`).
   - Возвращает атрибуты файла (например, `st_mode`, `st_size`).
   - Параметр `AT_EMPTY_PATH` вместе с пустым путем означает, что `fstatat/newfstatat` используют уже открытый дескриптор для получения метаданных.
2. **rt_sigprocmask(…)** / **rt_sigaction(…)**:
   - Управляют сигналами (установка или снятие блокировки, обработчиков сигналов).
   - sigprocmask` задает/считывает маску блокируемых сигналов.
   - `sigaction` (`rt_sigaction`) регистрирует обработчик для конкретного сигнала.
3. **mmap(…)** / **mprotect(…)** / **munmap(…)**:
   - `mmap` выделяет виртуальную память (обычно под стеки потоков или под другие буферы) или отображает файл в память.
   - `mprotect` меняет права доступа (`PROT_READ`, `PROT_WRITE`, `PROT_NONE`) для уже отмапленных страниц.
   - `munmap` освобождает область памяти.
4. **clone3(…)**:
   - Создает новый поток или процесс (в зависимости от флагов).
   - Здесь видны флаги `CLONE_VM`, `CLONE_FS`, `CLONE_FILES`, `CLONE_SIGHAND`, `CLONE_THREAD` и т. д. — они указывают, что создается поток (shared memory space, дескрипторы, обработчики сигналов и т.д.), а не отдельный процесс.
   - `stack=…` (и `stack_size=…`) — новый поток получает собственный стек по адресу, возвращенном mmap.
   - `child_tid=…` / `parent_tid=…` — механизмы для установки идентификаторов потока.

## Лабораторная работа №3

### Описание программы
Аналогично лабораторной работе №1, но используется `mmaping`, вместо `pipe`, для передачи данных.

### Команда для выполнения `strace`:

```sh
strace -o strace_lab_3.txt ./parent
```

### Анализ `strace`

1. **execve(…)**:  
   - Инициализирует запуск программы `parent`.  
   - Подгружает динамические библиотеки (`openat`, `mmap`) перед выполнением основного кода.

2. **unlink(…)**:  
   - Удаляет ранее созданные объекты (например, семафоры или файлы в `/dev/shm/sem.*`).
   - Часто используется для очистки окружения перед повторным созданием необходимых ресурсов.

3. **openat(…)** + **ftruncate(…)**:  
   - Создает или открывает отображаемый файл (шареную память) для межпроцессного взаимодействия.
   - `ftruncate` задает размер этого файла.

4. **mmap(…)** / **munmap(…)**: 
   - Отображает или освобождает разделяемую память, используемую для обмена данными.
   - При `MAP_SHARED` изменения видны всем процессам, подключенным через ту же память.

5. **getrandom(…)**:  
   - Получает случайные данные из генератора случайных чисел ядра (часто используется для генерации уникальных имен).

6. **link(…)**:  
   - Создает новую привязку (имя для ресурса), например, для семафора или временного файла.

7. **clone(…)**:  
   - Порождает дочерние процессы.  
   - Настраивает общий адресный пространство, дескрипторы, сигналы в зависимости от флагов.

8. **futex(…)**:  
   - Управляет блокировками/пробуждениями, часто используется внутри реализации семафоров.

9. **wait4(…)**:  
   - Родитель ждет завершения дочерних процессов, затем освобождает ресурсы.

Вся логика строится вокруг семафоров и отображаемых файлов, обеспечивая синхронизацию процессов (чтение/запись в общий сегмент памяти и уведомление о готовности данных).


## Лабораторная работа №4

### Описание программы
`Program1` использует линковку библиотек на этапе компиляции. `Program2` динамически загружает библиотеки с помощтю `dlopen`.

### Команда для выполнения `strace`:

```sh
strace -o strace_lab_4_prog_1.txt ./Program1
strace -o strace_lab_4_prog_2.txt ./Program2
```
### Анализ `strace`

**Program1** (линковка на этапе компиляции):  
1. **execve(…)** — запуск исполняемого файла.  
2. **openat(…)** — загрузка динамических библиотек (например, `libDerivative1.so`, `libPi1.so`), на которые программа ссылается еще во время компоновки.  
3. **mmap(…)** — отображение библиотек в память.  
4. **close(…)** — освобождение дескрипторов, не требуемых в дальнейшем.  
5. **read(…)** / **write(…)** — ввод команд, вывод результатов.

**Program2** (динамическая загрузка с помощью `dlopen`):  
1. **execve(…)** — запуск исполняемого файла.  
2. **openat(…)** — поиск библиотек, необходимых для базового окружения (например, `libc.so.6`).  
3. **read(…)** — чтение команд пользователя (например, «1 …», «2 …»).  
4. **dlopen(…)** / **dlsym(…)** / **dlclose(…)** — динамическая загрузка заданной библиотеки (например, `libDerivative1.so`, `libPi1.so`), получение символов функций и выгрузка библиотеки после выполнения.  
5. **mmap(…)** — отображение библиотек и других сегментов памяти.  
6. **write(…)** — вывод результатов, завершение программы.  